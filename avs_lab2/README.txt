avs_lab2_part1.cpp

Написать функцию, которая инстанциирует массив из NumTasks байт, в каждом из которых записан 0. Запустить NumThreads потоков, каждый из которых читает потокобезопасный индекс, увеличивает его на один и прибавляет единицу к элементу массива по этому индексу. Засечь время работы всех потоков. После завершения работы всех потоков, необходимо проверить корректность заполнения массива и вывести на экран время работы.

1. Реализовать потокобезопасный счетчик двумя способами: блокирующий при помощи std::mutex и неблокирующий при помощи std::atomic

2. Измерить время работы функции, использующей разные реализации счетчика при NumTasks=1024*1024 и NumThreads={4, 8, 16, 32}.

3. Добавьте усыпление потока на 10ns после каждого инкремента элемента массива. Повторите измерения из пункта 2.


PART_2

Написать код инстанциирующий ConsumerNum потребителей и ProducerNum производителей. Связать их потокобезопасной очередью, хранящей однобайтные элементы. Потребители инстанциируют локальный счетчик, после чего начинают читать очередь и прибавлять вычитанные значения к локальному счетчику. Каждый производитель записывает TaskNum единиц в очередь и завершает свою работу. Когда все производители записали свои сообщения и потребители опустошили очередь, потребители завершают свою работу и возвращают получившиеся суммы. Необходимо засечь время работы производителей и потребителей и проверить, что итоговая сумма результатов всех потребителей равна ProducerNum / TaskNum.
Протестировать для ProducerNum={1, 2, 4}, ConsumerNum={1, 2, 4}, TaskNum=4*1024*1024.
Интерфейс очереди:

class queue
{
  public:
    // Записывает элемент в очередь.
    // Гсли очередь фиксированного размер и заполнена,
    // поток повисает внутри функции пока не освободится место
    void push(uint8_t val);
    // Если очередь пуста, ждем 1 мс записи в очередь.
    // Если очередь не пуста, помещает значение головы в val,
    // удаляет голову и возвращает true.
    // Если очередь по прежнему пуста, возвращаем false
  bool pop(uint8_t& val);
};

Задачу необходимо решить для следующий вариантов реализации очереди:
avs_lab2_dynamic.cpp
1. Динамическая очередь с использованием std-контейнеров и std::mutex.

avs_lab2_fixed.cpp
2. Очередь фиксированного размера QueueSize с использованием std::mutex и std::condition_variable без busy wait. Протестировать для QueueSize={1, 4, 16}.

...
3. Очередь фиксированного размера с использованием std::atomic. Используйте std::conditinal_variable и std::mutex только чтобы оповещать потоки об освободившихся ячейках или новых задачах Протестировать для QueueSize={1, 4, 16}.
